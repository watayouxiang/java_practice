# Java内存模型

> Java内存模型定义了一种多线程访问Java内存的规范。
	
### 1.Java内存模型将内存分为了主内存和工作内存

- 类的状态，也就是类之间共享的变量，是存储在主内存中的，每次Java线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去

### 2.定义了几个原子操作，用于操作主内存和工作内存中的变量

- AtomicInteger原子性基于"CAS机制（Compare and Swap）"的“乐观锁”实现。
- synchronized 和 Lock 原子性基于“独占锁”实现。

### 3.定义了volatile变量的使用规则

- volatile保证可见性、有序性
	- 可见性：多线程操作变量时，都是等到线程代码执行完毕后才会把修改后的变量从工作内存更新到主内存中去，但是对 volatile修饰后的变量 操作，会立即更新到主内存中去。从而保证每次读取到volatile变量，一定是最新的数据，换句话说，volatile变量在各个线程中的值是一致的。
	- 有序性：为了获取更好的性能JVM会对指令进行重排序，使用volatile则会禁止指令重排序，从而确保了 “有序性”，遵循了java内存模型中的 “happens-before，即先行发生原则”，当然这也一定程度上降低了代码执行效率。

### 4.happens-before，即先行发生原则

- 定义了操作A必然先行发生于操作B的一些规则
- 比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码
- 一个释放锁unlock的动作一定先行发生于锁定lock动作
- 只要符合这些规则，则不需要额外做同步措施。如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的，需要额外同步措施，来保证线程的有序性。