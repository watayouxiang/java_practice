# Java并发特性

> 多线程问题，只要遵循了 “原子性、有序性、可见性” 就能确保线程安全。
> 
> 非常好的参考资料：https://www.cnblogs.com/dolphin0520/p/3920373.html

### Java并发特性（原子性、有序性、可见性）

- 原子性：是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其它线程干扰
- 有序性：即程序执行的顺序按照代码的先后顺序执行，禁止JVM指令重排序。
- 可见性：是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

### volatile保证可见性、有序性

- 可见性：多线程操作变量时，都是等到线程代码执行完毕后才会把修改后的变量从工作内存更新到主内存中去，但是对 volatile修饰后的变量 操作，会立即更新到主内存中去。从而保证每次读取到volatile变量，一定是最新的数据，换句话说，volatile变量在各个线程中的值是一致的。
- 有序性：为了获取更好的性能JVM会对指令进行重排序，使用volatile则会禁止指令重排序，从而确保了 “有序性”，遵循了java内存模型中的 “happens-before，即先行发生原则”，当然这也一定程度上降低了代码执行效率。

### “独占锁”和“乐观锁”保证原子性

原子性的实现方式有两种，“独占锁” 和 “乐观锁”

- 乐观锁
	- 乐观锁是先假定没有冲突直接进行操作，如果因为有冲突而失败就重试，直到操作成功。其中CAS机制（Compare and Swap）就是 “乐观锁”。
	- AtomicInteger 中的CAS操作就是compareAndSet()，其作用是每次从内存中根据内存偏移量（valueOffset）取出数据，将取出的值跟expect 比较，如果数据一致就把内存中的值改为update。这样CAS就保证了原子操作。  
- 独占锁
	- 独占锁就是线程获取锁后其他的线程都需要挂起，直到持有独占锁的线程释放锁。
	- synchronized 和 Lock 也是用来实现的原子操作的。
	- 但是它们比较影响性能，因为 “独占锁”，虽然可以实现原子操作，但是并发性能很差。